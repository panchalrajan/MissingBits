name: Auto Release Extension

on:
  pull_request:
    types:
      - closed
    branches:
      - main

jobs:
  release:
    # Only run on merged PRs from release or hotfix branches
    if: github.event.pull_request.merged == true && (startsWith(github.head_ref, 'release_') || startsWith(github.head_ref, 'hotfix_'))
    
    runs-on: macos-latest
    
    permissions:
      contents: write  # Required for creating releases and tags
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for proper tagging
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          
      - name: Install minification tools
        run: |
          npm install -g terser clean-css-cli html-minifier-terser
          
      - name: Extract version and name from manifest
        id: version
        run: |
          VERSION=$(node -p "require('./manifest.json').version")
          NAME=$(node -p "require('./manifest.json').name")
          SAFE_NAME=$(echo "$NAME" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "safe_name=$SAFE_NAME" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo "Extension name: $NAME"
          echo "Extension version: $VERSION"
          
      - name: Check if tag exists
        id: check_tag
        run: |
          if git rev-parse "v${{ steps.version.outputs.version }}" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Tag v${{ steps.version.outputs.version }} already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Tag v${{ steps.version.outputs.version }} does not exist"
          fi
          
      - name: Create build directory
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          mkdir -p build
          
      - name: Copy and minify files
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          # Copy icons and other assets as-is
          cp -r icons build/ 2>/dev/null || echo "No icons directory found"
          
          # Minify and copy HTML files
          echo "Minifying HTML files..."
          find . -name "*.html" -not -path "./build/*" -not -path "./.git/*" -not -path "./node_modules/*" | while read html_file; do
            if [ -f "$html_file" ]; then
              echo "Processing $html_file"
              rel_path="${html_file#./}"
              mkdir -p "build/$(dirname "$rel_path")"
              html-minifier-terser \
                --collapse-whitespace \
                --remove-comments \
                --remove-optional-tags \
                --remove-redundant-attributes \
                --remove-script-type-attributes \
                --remove-tag-whitespace \
                --use-short-doctype \
                --minify-css true \
                --minify-js true \
                --output "build/$rel_path" \
                "$html_file"
            fi
          done
          
          # Minify and copy JavaScript files
          echo "Minifying JavaScript files..."
          find . -name "*.js" -not -path "./build/*" -not -path "./.git/*" -not -path "./node_modules/*" | while read js_file; do
            if [ -f "$js_file" ]; then
              echo "Processing $js_file"
              rel_path="${js_file#./}"
              mkdir -p "build/$(dirname "$rel_path")"
              terser "$js_file" --compress --mangle --output "build/$rel_path"
            fi
          done
          
          # Minify and copy CSS files
          echo "Minifying CSS files..."
          find . -name "*.css" -not -path "./build/*" -not -path "./.git/*" -not -path "./node_modules/*" | while read css_file; do
            if [ -f "$css_file" ]; then
              echo "Processing $css_file"
              rel_path="${css_file#./}"
              mkdir -p "build/$(dirname "$rel_path")"
              cleancss -o "build/$rel_path" "$css_file"
            fi
          done
          
          # Minify and copy JSON files (excluding manifest.json)
          echo "Minifying JSON files..."
          find . -name "*.json" -not -name "manifest.json" -not -path "./build/*" -not -path "./.git/*" -not -path "./node_modules/*" | while read json_file; do
            if [ -f "$json_file" ]; then
              echo "Processing $json_file"
              rel_path="${json_file#./}"
              mkdir -p "build/$(dirname "$rel_path")"
              node -e "
                const fs = require('fs');
                const data = fs.readFileSync('$json_file', 'utf8');
                const minified = JSON.stringify(JSON.parse(data));
                fs.writeFileSync('build/$rel_path', minified);
              "
            fi
          done
          
          # Copy manifest.json as-is (no minification)
          echo "Copying manifest.json..."
          cp manifest.json build/
          
      - name: Create extension ZIP
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          cd build
          zip -r "../${{ steps.version.outputs.safe_name }}-v${{ steps.version.outputs.version }}.zip" .
          cd ..
          echo "Created ZIP: ${{ steps.version.outputs.safe_name }}-v${{ steps.version.outputs.version }}.zip"
          
      - name: Display build contents
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          echo "Build directory contents:"
          find build -type f -exec ls -la {} \;
          echo "ZIP file size:"
          ls -la *.zip

      - name: Create Safari Extension manifest and background script
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          echo "Creating Safari-compatible manifest and background script..."
          mkdir -p safari-build
          cp -r build/* safari-build/

          # Create Safari-compatible manifest
          node -e "
            const fs = require('fs');
            const manifest = JSON.parse(fs.readFileSync('safari-build/manifest.json', 'utf8'));

            // Add Safari-specific fields
            manifest.browser_specific_settings = {
              safari: {
                strict_min_version: '14.0'
              }
            };

            // Remove omnibox support for Safari (not well supported)
            if (manifest.omnibox) {
              delete manifest.omnibox;
              console.log('Removed omnibox support for Safari compatibility');
            }

            fs.writeFileSync('safari-build/manifest.json', JSON.stringify(manifest, null, 2));
            console.log('Safari manifest created');
          "

          # Create Safari-compatible background script
          echo "Creating Safari-compatible background script..."
          node -e "
            const fs = require('fs');
            const backgroundScript = fs.readFileSync('safari-build/background.js', 'utf8');

            // Create Safari-compatible version
            let safariBackground = backgroundScript
              // Replace chrome.* with browser.* for Safari compatibility
              .replace(/chrome\\.runtime/g, 'browser.runtime')
              .replace(/chrome\\.action/g, 'browser.action')
              .replace(/chrome\\.storage/g, 'browser.storage')
              .replace(/chrome\\.tabs/g, 'browser.tabs')
              // Remove omnibox functionality entirely for Safari
              .replace(/\/\/ Omnibox functionality[\s\S]*$/m, '// Omnibox functionality removed for Safari compatibility');

            // Add fallback for browser API
            const safariWrapper = \`// Safari-compatible background script
// Fallback to chrome API if browser API is not available
if (typeof browser === 'undefined' && typeof chrome !== 'undefined') {
    globalThis.browser = chrome;
}

\${safariBackground}\`;

            fs.writeFileSync('safari-build/background.js', safariWrapper);
            console.log('Safari-compatible background script created');
          "

      - name: Convert to Safari Extension
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          echo "Converting to Safari extension..."

          # Use Safari Web Extension Converter (macOS only)
          xcrun safari-web-extension-converter safari-build \
            --project-location safari-project \
            --app-name "${{ steps.version.outputs.name }}" \
            --bundle-identifier "com.github.${{ github.repository_owner }}.${{ steps.version.outputs.safe_name }}" \
            --swift \
            --macos-only \
            --copy-resources

          echo "Safari extension project created"

      - name: Build Safari Extension
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          echo "Building Safari extension..."
          cd safari-project

          # Find the .xcodeproj file
          PROJECT_FILE=$(find . -name "*.xcodeproj" -type d | head -1)

          if [ -n "$PROJECT_FILE" ]; then
            echo "Found project: $PROJECT_FILE"

            # List available schemes
            echo "Available schemes:"
            xcodebuild -project "$PROJECT_FILE" -list

            # Get the first available scheme
            SCHEME=$(xcodebuild -project "$PROJECT_FILE" -list | grep -A 100 "Schemes:" | grep -v "Schemes:" | head -1 | xargs)

            if [ -n "$SCHEME" ]; then
              echo "Using scheme: $SCHEME"
              xcodebuild -project "$PROJECT_FILE" \
                -scheme "$SCHEME" \
                -configuration Release \
                -derivedDataPath DerivedData \
                build

              # Find the built app
              APP_PATH=$(find DerivedData -name "*.app" -type d | head -1)

              if [ -n "$APP_PATH" ]; then
                echo "Safari app built at: $APP_PATH"
                cp -r "$APP_PATH" "../${{ steps.version.outputs.safe_name }}-Safari-v${{ steps.version.outputs.version }}.app"
              else
                echo "Warning: Safari app not found in build output"
                echo "DerivedData contents:"
                find DerivedData -type f -name "*.app" || echo "No .app files found"
              fi
            else
              echo "Warning: No schemes found in project"
            fi
          else
            echo "Warning: No .xcodeproj file found"
          fi

      - name: Package Safari Extension
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          if [ -d "${{ steps.version.outputs.safe_name }}-Safari-v${{ steps.version.outputs.version }}.app" ]; then
            echo "Creating Safari app archive..."
            zip -r "${{ steps.version.outputs.safe_name }}-Safari-v${{ steps.version.outputs.version }}.zip" \
              "${{ steps.version.outputs.safe_name }}-Safari-v${{ steps.version.outputs.version }}.app"
            echo "Safari extension packaged successfully"
            ls -la *Safari*.zip
          else
            echo "Safari app not found, skipping Safari packaging"
          fi
          
      - name: Create Git tag
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag "${{ steps.version.outputs.tag }}"
          git push origin "${{ steps.version.outputs.tag }}"
          
      - name: Create GitHub Release with Assets
        if: steps.check_tag.outputs.exists == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Prepare release assets
          ASSETS=("${{ steps.version.outputs.safe_name }}-v${{ steps.version.outputs.version }}.zip")

          # Add Safari extension if it exists
          if [ -f "${{ steps.version.outputs.safe_name }}-Safari-v${{ steps.version.outputs.version }}.zip" ]; then
            ASSETS+=("${{ steps.version.outputs.safe_name }}-Safari-v${{ steps.version.outputs.version }}.zip")
            SAFARI_NOTES="

            ### üçé Safari Extension
            - Download the \`-Safari-\` version for macOS Safari
            - Requires macOS 10.14+ and Safari 14+
            - Double-click the .app to install"
          else
            SAFARI_NOTES=""
          fi

          # Create release
          gh release create "${{ steps.version.outputs.tag }}" \
            --title "${{ steps.version.outputs.name }} ${{ steps.version.outputs.tag }}" \
            --notes "## ${{ steps.version.outputs.name }} ${{ steps.version.outputs.tag }}

            ### üì¶ Downloads
            - **Chrome/Firefox**: Download the main ZIP file
            - **Safari (macOS)**: Download the Safari ZIP file${SAFARI_NOTES}

            ### üîß Technical Details
            - **Version**: ${{ steps.version.outputs.version }}
            - **Build Date**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
            - **Commit**: ${{ github.sha }}

            ---
            *Auto-generated release - description will be updated manually*" \
            --latest \
            "${ASSETS[@]}"
          
      - name: Release created successfully
        if: steps.check_tag.outputs.exists == 'false'
        run: |
          echo "‚úÖ Release ${{ steps.version.outputs.tag }} created successfully!"
          echo "üì¶ Chrome/Firefox ZIP: ${{ steps.version.outputs.safe_name }}-v${{ steps.version.outputs.version }}.zip"

          if [ -f "${{ steps.version.outputs.safe_name }}-Safari-v${{ steps.version.outputs.version }}.zip" ]; then
            echo "üçé Safari Extension: ${{ steps.version.outputs.safe_name }}-Safari-v${{ steps.version.outputs.version }}.zip"
          else
            echo "‚ö†Ô∏è Safari extension build failed or skipped"
          fi

          echo "üîó Check the release at: ${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ steps.version.outputs.tag }}"
          
      - name: Skip duplicate release
        if: steps.check_tag.outputs.exists == 'true'
        run: |
          echo "‚ö†Ô∏è Release ${{ steps.version.outputs.tag }} already exists, skipping..."
          echo "If you want to create a new release, update the version in manifest.json"